{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/scripts/app.js","webpack:///./src/styles/app.scss?9815"],"names":["overlay","document","querySelector","navbar","btnMenu","textMenu","body","listeLiens","addEventListener","e","preventDefault","classList","contains","remove","innerHTML","add","followCursor","cursor","getElementById","hoverTargets","querySelectorAll","event","posX","pageX","posY","pageY","style","left","offsetWidth","top","offsetHeight","window","onscroll","myFunction","winScroll","scrollTop","documentElement","height","scrollHeight","clientHeight","scrolled","width","sections","progressBar","pixels","pageYOffset","forEach","section","offsetTop","isDark","hasAttribute"],"mappings":"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","file":"/dist/scripts/app.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/* AFFICHAGE OVERLAY */\nvar overlay = document.querySelector('.overlay');\nvar navbar = document.querySelector('.navbar');\nvar btnMenu = document.querySelector('.btn-menu');\nvar textMenu = document.querySelector('.btn-menu a');\nvar body = document.querySelector('body');\nvar listeLiens = document.querySelector('.overlay__list');\n\nbtnMenu.addEventListener('click', function(e) {\n    /* Doc : The preventDefault() method stops the default action of a selected element from happening by a user. */\n    e.preventDefault();\n  \n    if (overlay.classList.contains('afficherMenu')) {\n        overlay.classList.remove('afficherMenu');\n        textMenu.innerHTML = \"menu\";\n        navbar.classList.add('overlay--shadow');\n    } else {\n        overlay.classList.add('afficherMenu');\n        textMenu.innerHTML = \"fermer\";\n        navbar.classList.remove('overlay--shadow');\n    }\n    listeLiens.addEventListener('click', function(e) {\n        overlay.classList.remove('afficherMenu');\n        navbar.classList.add('overlay--shadow');\n        textMenu.innerHTML = \"menu\";\n    });\n});\n\n/* CURSOR FOLLOW */\nfunction followCursor() {\n    const cursor = document.getElementById(\"main-cursor\");\n    const followCursor = document.getElementById(\"follow-cursor\");\n    const hoverTargets = document.querySelectorAll(\".mouse-hover\");\n\n    document.addEventListener(\"mousemove\", function(event) {\n        const { pageX: posX, pageY: posY } = event;\n        cursor.style.left = `${posX - cursor.offsetWidth / 2}px`;\n        cursor.style.top = `${posY - cursor.offsetHeight / 2}px`;\n        followCursor.style.left = `${posX - followCursor.offsetWidth / 2}px`;\n        followCursor.style.top = `${posY - followCursor.offsetHeight / 2}px`;\n    });\n}\nfollowCursor();\n\n/* PROGRESS BAR */\nwindow.onscroll = function() {myFunction()};\nfunction myFunction() {\n    var winScroll = document.body.scrollTop || document.documentElement.scrollTop;\n    var height = document.documentElement.scrollHeight - document.documentElement.clientHeight;\n    var scrolled = (winScroll / height) * 100;\n    document.getElementById(\"myBar\").style.width = scrolled + \"%\";\n}\n\n/* SWITCH COLOR IF ON DARK SECTION */\nconst sections = document.querySelectorAll('section')\nconst progressBar = document.querySelector('.progress-bar')\n\ndocument.addEventListener(\"scroll\", function () {\n    const pixels = window.pageYOffset  \n    sections.forEach(section => {\n        if (section.offsetTop - 20 <= pixels) {\n            const isDark = section.hasAttribute('data-is-dark')\n\n            if (isDark) {\n                progressBar.classList.add('white')\n            } else {\n                progressBar.classList.remove('white')\n            }\n        }\n    })\n})\n\n/*\n* demo.js\n* http://www.codrops.com\n*\n* Licensed under the MIT license.\n* http://www.opensource.org/licenses/mit-license.php\n* \n* Copyright 2019, Codrops\n* http://www.codrops.com\n*/\n\n/*\n{\n    // helper functions\n    const MathUtils = {\n        // map number x from range [a, b] to [c, d]\n        map: (x, a, b, c, d) => (x - a) * (d - c) / (b - a) + c,\n        // linear interpolation\n        lerp: (a, b, n) => (1 - n) * a + n * b\n    };\n\n    // body element\n    const body = document.body;\n    \n    // calculate the viewport size\n    let winsize;\n    const calcWinsize = () => winsize = {width: window.innerWidth, height: window.innerHeight};\n    calcWinsize();\n    // and recalculate on resize\n    window.addEventListener('resize', calcWinsize);\n\n    // scroll position and update function\n    let docScroll;\n    const getPageYScroll = () => docScroll = window.pageYOffset || document.documentElement.scrollTop;\n    window.addEventListener('scroll', getPageYScroll);\n    \n    // Item\n    class Item {\n        constructor(el) {\n            // the .item element\n            this.DOM = {el: el};\n            // the inner image\n            this.DOM.image = this.DOM.el.querySelector('.item__img');\n            console.log(this.DOM.image);\n            this.renderedStyles = {\n                // here we define which property will change as we scroll the page and the items is inside the viewport\n                // in this case we will be translating the image on the y-axis\n                // we interpolate between the previous and current value to achieve a smooth effect\n                innerTranslationY: {\n                    // interpolated value\n                    previous: 0, \n                    // current value\n                    current: 0, \n                    // amount to interpolate\n                    ease: 0.1,\n                    // the maximum value to translate the image is set in a CSS variable (--overflow)\n                    maxValue: parseInt(getComputedStyle(this.DOM.image).getPropertyValue('--overflow'), 10),\n                    // current value setter\n                    // the value of the translation will be:\n                    // when the item's top value (relative to the viewport) equals the window's height (items just came into the viewport) the translation = minimum value (- maximum value)\n                    // when the item's top value (relative to the viewport) equals \"-item's height\" (item just exited the viewport) the translation = maximum value\n                    setValue: () => {\n                        const maxValue = this.renderedStyles.innerTranslationY.maxValue;\n                        const minValue = -1 * maxValue;\n                        return Math.max(Math.min(MathUtils.map(this.props.top - docScroll, winsize.height, -1 * this.props.height, minValue, maxValue), maxValue), minValue)\n                    }\n                }\n            };\n            // set the initial values\n            this.update();\n            // use the IntersectionObserver API to check when the element is inside the viewport\n            // only then the element translation will be updated\n            this.observer = new IntersectionObserver((entries) => {\n                entries.forEach(entry => this.isVisible = entry.intersectionRatio > 0);\n            });\n            this.observer.observe(this.DOM.el);\n            // init/bind events\n            this.initEvents();\n        }\n        update() {\n            // gets the item's height and top (relative to the document)\n            this.getSize();\n            // sets the initial value (no interpolation)\n            for (const key in this.renderedStyles ) {\n                this.renderedStyles[key].current = this.renderedStyles[key].previous = this.renderedStyles[key].setValue();\n            }\n            // translate the image\n            this.layout();\n        }\n        getSize() {\n            const rect = this.DOM.el.getBoundingClientRect();\n            this.props = {\n                // item's height\n                height: rect.height,\n                // offset top relative to the document\n                top: docScroll + rect.top \n            }\n        }\n        initEvents() {\n            window.addEventListener('resize', () => this.resize());\n        }\n        resize() {\n            // on resize rest sizes and update the translation value\n            this.update();\n        }\n        render() {\n            // update the current and interpolated values\n            for (const key in this.renderedStyles ) {\n                this.renderedStyles[key].current = this.renderedStyles[key].setValue();\n                this.renderedStyles[key].previous = MathUtils.lerp(this.renderedStyles[key].previous, this.renderedStyles[key].current, this.renderedStyles[key].ease);\n            }\n            // and translates the image\n            this.layout();\n        }\n        layout() {\n            // translates the image\n            this.DOM.image.style.transform = `translate3d(0,${this.renderedStyles.innerTranslationY.previous}px,0)`;\n        }\n    }\n    \n    // SmoothScroll\n    class SmoothScroll {\n        constructor() {\n            // the <main> element\n            this.DOM = {main: document.querySelector('main')};\n            // the scrollable element\n            // we translate this element when scrolling (y-axis)\n            this.DOM.scrollable = this.DOM.main.querySelector('div[data-scroll]');\n            // the items on the page\n            this.items = [];\n            [...this.DOM.main.querySelectorAll('.content > .item')].forEach(item => this.items.push(new Item(item)));\n            // here we define which property will change as we scroll the page\n            // in this case we will be translating on the y-axis\n            // we interpolate between the previous and current value to achieve the smooth scrolling effect\n            this.renderedStyles = {\n                translationY: {\n                    // interpolated value\n                    previous: 0, \n                    // current value\n                    current: 0, \n                    // amount to interpolate\n                    ease: 0.1,\n                    // current value setter\n                    // in this case the value of the translation will be the same like the document scroll\n                    setValue: () => docScroll\n                }\n            };\n            // set the body's height\n            this.setSize();\n            // set the initial values\n            this.update();\n            // the <main> element's style needs to be modified\n            this.style();\n            // init/bind events\n            this.initEvents();\n            // start the render loop\n            requestAnimationFrame(() => this.render());\n        }\n        update() {\n            // sets the initial value (no interpolation) - translate the scroll value\n            for (const key in this.renderedStyles ) {\n                this.renderedStyles[key].current = this.renderedStyles[key].previous = this.renderedStyles[key].setValue();\n            }   \n            // translate the scrollable element\n            this.layout();\n        }\n        layout() {\n            // translates the scrollable element\n            this.DOM.scrollable.style.transform = `translate3d(0,${-1*this.renderedStyles.translationY.previous}px,0)`;\n        }\n        setSize() {\n            // set the height of the body in order to keep the scrollbar on the page\n            body.style.height = `${this.DOM.scrollable.scrollHeight}px`;\n        }\n        style() {\n            // the <main> needs to \"stick\" to the screen and not scroll\n            // for that we set it to position fixed and overflow hidden \n            this.DOM.main.style.position = 'fixed';\n            this.DOM.main.style.width = this.DOM.main.style.height = '100%';\n            this.DOM.main.style.top = this.DOM.main.style.left = 0;\n            this.DOM.main.style.overflow = 'hidden';\n        }\n        initEvents() {\n            // on resize reset the body's height\n            window.addEventListener('resize', () => this.setSize());\n        }\n        render() {\n            // update the current and interpolated values\n            for (const key in this.renderedStyles ) {\n                this.renderedStyles[key].current = this.renderedStyles[key].setValue();\n                this.renderedStyles[key].previous = MathUtils.lerp(this.renderedStyles[key].previous, this.renderedStyles[key].current, this.renderedStyles[key].ease);\n            }\n            // and translate the scrollable element\n            this.layout();\n            \n            // for every item\n            for (const item of this.items) {\n                // if the item is inside the viewport call it's render function\n                // this will update the item's inner image translation, based on the document scroll value and the item's position on the viewport\n                if ( item.isVisible ) {\n                    item.render();\n                }\n            }\n            \n            // loop..\n            requestAnimationFrame(() => this.render());\n        }\n    }\n*/\n    /***********************************/\n    /********** Preload stuff **********/\n\n    // Preload images\n    /*\n    const preloadImages = () => {\n        return new Promise((resolve, reject) => {\n            imagesLoaded(document.querySelectorAll('.item__img'), {background: true}, resolve);\n        });\n    };\n    \n    // And then..\n    preloadImages().then(() => {\n        // Remove the loader\n        document.body.classList.remove('loading');\n        // Get the scroll position\n        getPageYScroll();\n        // Initialize the Smooth Scrolling\n        new SmoothScroll();\n    });\n    }\n    */","// removed by extract-text-webpack-plugin"],"sourceRoot":""}